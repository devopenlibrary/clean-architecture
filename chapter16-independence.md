# 16장 독립성

좋은 아키텍처는 다양한 관점에서의 ‘**독립성**’을 보장해주는 구조다.

**좋은 아키텍처가 지원해야 할 네 가지**

1. 유스케이스
2. 운영
3. 개발
4. 배포

이 네 가지가 서로 간섭하지 않고 독립적으로 움직일 수 있도록 만들어주는 것이 아키텍처의 역할

## 유스케이스

**아키텍처의 최우선 관심사는 유스케이스**이다.

- 아키텍처는 시스템의 유스케이스(행위와 의도)를 잘 드러내고 명확히 보여줘야 한다.
    - 명확한 행위를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것
- 좋은 아키텍처는 시스템의 동작을 이해하기 쉽게 만든다.
    - 구조만 봐도 “이건 장바구니 애플리케이션이구나~” 하고 알 수 있어야 한다.
- 유스케이스는 아키텍처 내에서 **일급 요소**이어야 하며, 일일이 찾지 않아도 시스템의 구조 속에서 **눈에 띄게 존재**해야 한다.
    - 클래스이거나 함수 또는 모듈로서 아키텍처 내에서 핵심적인 자리를 차지
    - 자신의 기능을 분명하게 설명하는 이름 소유

## 운영

운영상의 요구사항 (예: 처리량, 응답 시간, 빅데이터 처리)을 수용할 수 있는 구조여야 한다.

- 아키텍처는 다양한 운영 요구를 **미리 고려한 확장성 있는 구조**를 가져야 한다.
    
    예시
    
    - 마이크로서비스 → 병렬처리
    - 단일 스레드 → 자원 절약
    - 소수의 프로세스
    - 모노리스
        
        → 요구사항은 항상 바뀔 수 있음. 중요한 건 **유연성!**
        
- 아키텍트가 이러한 결정을 선택사항으로 열어 두면  요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 쉬워진다.
    - 각 컴포넌트를 적절히 격리
    - 컴포넌트 간 통신 방식을 특형 형태로 제한x

## 개발

- **콘웨이의 법칙**
    
    : 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
    
    👉 조직의 커뮤니케이션 구조는 시스템 구조에 반영된다.
    
    👉 팀 구성에 따라 아키텍처도 영향을 받는다. 
    
- 많은 팀으로 구성되어 관심사가 다양한 조식에서 시스템을 개발 한다면 팀들이 **서로 간섭하지 않고 독립적으로 개발**할 수 있게 아키텍처를 짜야 한다.
    - 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할

## 배포

아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다.

목표: 즉각적인 배포(immediate deplayment)

- 좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않는다.
- 좋은 아키텍처는 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다.
- 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
    
    
    👉 **시스템을 컴포넌트 단위로적절하게 분할하고 격리(**마스터 컴포넌트도 포함)
    

## 선택사항 열어놓기

좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다. 

❌ **현실에선 어려움**

- 대부분의 경우 모든 유스케이스를 알 수는 없음
    - 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못함
- 요구사항은 불확실하고 계속 변함.

**그럼에도 몇몇 아키텍처 원칙들은**

- 낮은 비용으로 관심사들 사이에서 균형을 잡는데 도움이 된다. (목표점을 명확히 그릴 수 없는 경우에도..)
- 시스템을 제대로 격리된 컴포넌트 단위로 분할하고, 미래의 변화에 대응할 수 있도록 가능한 한 많이, 오랫동안 선택지를 열어둔다.

## 계층 결합 분리

아키텍트는 모든 유스케이스 알지 못한다. 하지만 시스템의 기본적인 의도는 알고 있다. 따라서 아키텍트는 단일 책임 원칙과 공동 폐쇄 원칙을 적용하여 변경 사유가 다른 구성요소를 분리해야 한다.

**(예시) 서로 다른 이유로 변경되는 것?**

- UI 변경 vs 업무 규칙: 둘은 아무런 관련이 없다.
    - UI: 화면, 상호작용, 사용자의 기대에 따라 바뀐다.
    - 업무 규칙: 비즈니스의 로직과 정책에 따라 바뀐다.
        - 두 가지는 변경 사유가 완전히 다르기 때문에, 한 유스케이스 안에 있더라도 구조적으로 분리해야 한다.
    

**수평적인 계층**

시스템을 서로 다른 관심사를 기반으로 수평적 계층으로 나눈다.

- **UI**
- **애플리케이션 업무 규칙**:  입력 유효성 검사
- **도메인 업무 규칙**: 계좌 이자 계산, 재고품 집계
- **데이터베이스**

👉 각 계층은 서로 독립적으로 변경 가능해야 하며, 상위 계층이 하위 계층에 직접 의존하지 않는다. (DIP) 

## 유스케이스 결합 분리

서로 다른 유스케이스가 하나의 코드 구조 안에 얽혀 있지 않도록 분리하는 것

- 유스케이스 그 자체도 서로 다른 이유로 변경된다.
    - 주문 추가: 마케팅..
    - 주문 삭제: 규제나 보안..
        
        👉 하나의 유스케이스가 변경될 때 다른 유스케이스가 영향을 받아선 안 된다
        
- 유스케이스는 **수직 단위의 구성 요소**로, 시스템의 모든 계층을 관통한다
    - UI → Application → Domain → DB
        
        ```
        [ UI ]              ← 화면, 버튼
        ↓
        [ Application ]     ← 유스케이스 서비스
        ↓
        [ Domain ]          ← 비즈니스 로직
        ↓
        [ Database ]        ← 저장/조회
        ```
        

**이렇게 결합을 분리하려면?**

시스템의 맨 아래 계층까지 수직으로 내려가며 유스케이스들이 각 계층에서 서로 겹치지 않게 한다. 

❌ `OrderController, OrderService` 클래스가 주문 추가, 주문 삭제, 주문 변경을 전부 담당

- 주문 삭제 관련 변경이 생기면 → 주문 추가 로직 테스트도 해야 하나?

👍 유스케이스별로 **별도의 클래스와 구성** 분리

```java
OrderAddController
OrderAddService
OrderAddRepository

OrderDeleteController
OrderDeleteService
OrderDeleteRepository
```

- 하나가 바뀌어도 다른 유스케이스는 전혀 영향받지 않는다.

## 결합분리 모드

유스케이스의 결합 분리는 운영 관점에서도 큰 이점을 준다.

**운영 효율성**

- 서로 다른 처리량 요구를 가진 유스케이스는 분리되어 있는 경우가 많다.
    - 고빈도 → 서버 분산, 캐싱
    - 빈도 → 단일 인스턴스
- UI와 DB가 업무 규칙과 분리되어 있다면 서로 다른 서버에서 실행 가능하다.
    
    

**운영의 이점을 살리기 위한 결합 분리**

- 만약 분리된 컴포넌트가 다른 서버에서 실행되어야 한다면?
    - 같은 프로세스 공간에 함께 만들어선 안 된다.
    - 각 컴포넌트는 독립된 서비스여야 하며, 네트워크 통신으로 연결되어야 한다.

> 이러한 구조는 흔히 "서비스(Service)", 또는 "마이크로서비스(Microservice)"라고 한다.
> 

핵심

컴포넌트를 어디까지 분리할지를 선택할 수 있어야 한다는 것!

좋은 아키텍처는 항상 선택권을 열어두며 결합 분리 모드 역시 그 선택지 중 하나다.

## 개발 독립성

컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다. 

예시

- UI 팀 ↔ 업무 규칙 팀이 서로 독립적으로 개발 가능
- `OrderAdd` 팀 ↔ `OrderDelete` 팀이 서로 영향 없이 작업 가능

결합이 잘 분리되어 있다면?

- 어떤 팀 구조(기능 팀, 컴포넌트 팀, 계층 팀 등)에서도  ****대응 가능

## 배포 독립성

유스케이스와 계층의 결합을 분리하면, 배포 역시 유연해진다.

- 유스케이스 단위로 핫 스왑(hot-swap) 가능
    - 시스템 전체를 내리지 않고, 특정 기능만 교체
- 새로운 유스케이스는 기존 시스템에 영향 없이 jar 파일이나 서비스 몇 개 추가로 끝날 수 있다

## 중복

모든 중복이 나쁜 것은 아니다. **진짜 중복과 우발적(거짓) 중복**을 구분해야한다.

1. 진짜 중복: A 코드 변경 → B 코드도 항상 똑같이 변경
2. 우발적 중복: 처음엔 같아 보여도, 다른 방향으로 발전할 코드

**예시**

- 두 유스케이스의 UI가 비슷함
    
    → 통합하고 싶다..!
    
    ❌ 하지만 시간이 지나면 서로 다르게 진화할 가능성 높음
    
- 데이터베이스 레코드 구조 == 화면 출력 구조
    
    → ViewModel 없이 바로 DB 객체를 UI에 전달하고 싶다..!
    
    ❌ 하지만 이는 계층 간 결합을 유발.
    

## 결합 분리 모드(다시)

**결합 분리의 3가지 모드**

1. **소스 수준 분리 모드**
    - 모듈 레벨
        - 모듈이 변해도 다른 모듈을 재컴파일/빌드할 필요 없음
    - 같은 주소 공간에서 실행 가능, 함수 호출로 사용
    - 메모리에는 하나의 실행파일만 로드
    - 모노리식 구조에서 주로 사용

1. **배포 수준 분리 모드**
    - Jar, DLL, 공유 라이브러리 등 독립 배포 단위
        - 배포 가능한 단위들 사이의 의존성 제어 가능
        - 한 모듈에 변화가 있어도 다른 모듈을 재빌드/재배포 하지 않을 수 있다.
    - 같은 주소 공간에서 실행 가능, 함수 호출로 사용
    - 다른 프로세스에서 실행하거나, IPC(소켓, 공유 메모리 등) 사용도 가능

1. **서비스 수준 분리 모드**
    - 데이터 구조까지 의존하지 않도록 분리
    - 네트워크 패킷 통신만으로 연결

**모드 선택은 어떻게?**

정답은 없다. 프로젝트가 성숙해갈수록 최적인 모드가 달라질 수 있다. 

**현 시점의 해결책** 

서비스 수준에서의 분리를 기본 정책으로 삼는다. 컴포넌트 결합을 분리하되 서비스가 되기 직전에 멈춘다.

서비스화될 가능성에 대비해서 필요한 순간까지 서비스화를 미뤄 효율성을 확보한다.

1. 초기에는 소스 수준 분리로 시작
2. 개발·배포·운영이 복잡해질수록 → 배포 수준 → 서비스 수준으로 전환
    - 가능한 한 오랫동안 한 주소 공간 안에 머물게 한다.
        - 자원 낭비 방지
        - 개발 속도 유지

서비스 수준까지 나눈 후에도, 운영 요건이 줄어든다면 다시 모노리식 구조로 되돌릴 수 있어야 한다. 

좋은 아키텍처는 이러한 변경으로부터 소스 코드 대부분을 보호하고 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.

## 결론

시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 한다