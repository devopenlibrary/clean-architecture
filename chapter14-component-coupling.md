# 14장 컴포넌트 결합

_지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다. 이 장에서도 마찬가지로 개발 가능성과 논리적 설계 사이의 균형을 다룬다. 컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다._

## ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안된다.

'숙취 증후군'은 **많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생**한다.

이 문제의 해결책으로 두 가지 방법이 발전되어 왔다. 첫 번째는 '주 단위 빌드'이며, 두 번째 해결책은 '의존성 비순환 원칙' 이다.

### 주 단위 빌드(Weekly Build)

주 단위 빌드를 하는 방법은 다음과 같다. 

1. 모든 개발자는 일주일의 첫 4일 동안은 서로를 신경쓰지 않는다. 전체적인 기준에서 어떻게 통합할지에 대해 고민하지 않는다.
2. 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.

이 접근법은 **중간 규모의 프로젝트에서는 흔하게 사용되며 효과적**일 수 있다. 하지만 프로젝트가 커지면, **통합은 금요일 하루만에 끝내는 것이 불가**해진다.

개발보다 통합에 드는 시간이 늘어나며 팀의 효율성도 나빠진다. 그 방안으로 격주 빌드를 생각할 수 있겠지만, 임시 방편에 불과하며 프로젝트 규모가 성장하면 또다시 통합에 드는 시간은 늘어난다.

이 같은 흐름은 결국 위기를 초래한다. 빌드 일정을 계속 늘려야 하며, 통합과 테스트를 수행하기는 점점 더 어려워 진다.

### 순환 의존성 제거하기

이 문제의 해결책은 **개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것**이다. 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 **책임 질 수 있는 작업 단위**가 된다. 

**하나의 컴포넌트가 동작되도록 만든 후, 릴리스하여 다른 개발자가 사용할 수 있도록 만든다.** 담당 개발자는 컴포넌트에 릴리스 번호를 부여하고, 다른 개발자들이 사용할 수 있는 디렉터리로 이동시킨다. 그 다음, 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다.

따라서 **컴포넌트의 변경이 팀에 즉각적인 영향을 주지 않는다.** 각 팀은 특정 컴포넌트가 새로 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정 할 수 있다.

하지만 이러한 절차가 성공적으로 동작하려면 **컴포넌트 사이의 의존성 구조를 반드시 관리해야한다.**

---

다음 그림은 컴포넌트를 조립하여 애플리케이션을 만드는 다소 전형적인 구조를 보인다. 이 구조는 방향 그래프이다. 따라서, **컴포넌트는 정점**에 해당하고 **의존성 관계는 방향이 있는 간선**에 해당한다.

또한, 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수없다. 즉, 이 구조는 순환이 없는 비순환 방향 그래프다.

![alt text](/img/chapter14/component-diagram.png)
_그림 14.1 전형적인 컴포넌트 다이어그램_

**`Presenters` 컴포넌트를 담당하는 팀에서 새로운 릴리스를 만들었다고 쳐보자.** 어떤일이 벌어질지는 의존성 화살표를 거꾸로 따라가면 된다.

즉, `View`와 `Main` 컴포넌트 둘 다 영향을 받는다. 또한, `Main`은 새로 릴리스되더라도 영향을 받는 컴포넌트는 전혀 없다. 나머지 컴포넌트는 `Main`에 대해 알지 못하기 때문이다.

`Presenters` 컴포넌트를 만드는 개발자는 테스트를 하려면 `Interactors`와 `Entities`를 이용해 자체 버전을 빌드하기만 하면된다. 즉, **이 컴포넌트를 빌드할때 다른 컴포넌트는 관련이 전혀 없는 것이다**.

**만약 시스템 전체를 릴리스해야 할 때가 오면 절차는 상향식으로 진행된다**. `Entities` 컴포넌트를 먼저 컴파일하고, 테스트하고, 릴리스한다. 그다음에는 `Presentors`, `View`, `Controllers`, `Authorizer` 순으로 진행한다. 이와 같은 절차는 명료하며 쉽게 처리할 수 있다.

### 순환이 컴포넌트 의존성 그래프에 미치는 영향

새로운 요구사항이 발생해 `Entities`에 포함된 클래스 하나가 `Authorizer`에 포함된 클래스 하나를 사용하도록 변경할 수 밖에 없다고 가정해 보자. 이렇게 되면 다음 그림에서 보듯이 순환 의존성이 발생한다.

![alt text](/img/chapter14/a-dependency-cycle.png)
_그림 14.2 순환 의존성_

이 순환은 문제를 일으킨다.

예를 들어, `Database` 컴포넌트 담당 개발자는 릴리스할 때, `Entities` 컴포넌트와 반드시 호환되어야 한다는 사실을 알고 있다. 하지만 `Entities` 컴포넌트는 `Authorizer` 컴포넌트와 순환이 발생하였으므로, `Database` 컴포넌트는 `Authorizer` 컴포넌트와도 호환되어야 한다. 그런데 `Authorizer` 는 `Interactors` 에 의존한다. 따라서 `Database` 컴포넌트를 릴리스하기는 매우 까다로워진다.

이말은 결국 **이 컴포넌트들이 하나의 컴포넌트가 된다는 것이고, 각 컴포넌트는 독립된 개발환경을 보장받지 못하는 것이다**. 또다시 숙취 증후군을 겪게 되는 것이다. 이것이 순환이 컴포넌트 의존성에 미치는 영향이다.

- 각 컴포넌트 담당 개발자는 다른 컴포넌트에 얽매이게 된다. 
- 각 컴포넌트를 테스트할 때 다른 컴포넌트 또한 빌드하고 통합해야한다.
- 각 컴포넌트를 어떤 순서로 빌드할지 파악하는 것이 힘들어진다. 

### 순환 끊기
컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG(비순환 방향 그래프)로 돌리는 것은 언제든 가능하다. 다음 메커니즘 두가지를 살펴보자.

1. DIP(의존성 역전 원칙)을 적용한다. 다음 그림 14.3 처럼 `User`가 필요로 하는 메서드를 제공하는 **인터페이스를 생성**한다. 그리고 **이 인터페이스는 `Entities`에 위치시키고, `Authorizer`에서는 이 인터페이스를 상속**받는다. 이렇게 하면 둘 사이의 의존성은 역전되고 순환은 깨지게 된다.

    ![alt text](/img/chapter14/dip.png)
_그림 14.3 Entities와 Authorizer 사이의 의존성을 역전시킨다._

2. `Entities`와 `Authorizer`가 **모두 의존하는 새로운 컴포넌트(`Permissions`)**를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

    ![alt text](/img/chapter14/new-component.png)

### 흐트러짐(Jitters)
두 번째 해결책에서 시사하는 바는 **요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실**이다.

실제로 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 성장한다. 따라서 의존성 구조에 순환이 발생하는 지 항상 관찰하고, 순환이 발생하면 이와 같은 메커니즘으로 끊어내야 한다.

## 하향식(top-down) 설계

지금까지의 논의를 따르면 컴포넌트 구조는 하향식으로 설계될 수 없다. **컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 시스템이 변경/성장 할 때 비로소 진화한다.**

사실 컴포넌트 의존성 다이어그램(그래프)는 **애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다.** 오히려 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다. **이러한 이유 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.**

하지만 구현과 설계가 이루어지지 않은 프로젝트 초기에 모듈들이 점차 쌓이면, 의존성 관리에 대한 요구가 점차 늘어나게 된다. 

따라서 **아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도한다면 상당히 큰 실패를 맛볼 수 있다.** 공통 폐쇄에 대해 그다지 파악하지 못하고, 재사용 가능한 요소도 알지 못하기 때문이다.

**컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 진화해야한다.**

## SDP: 안정된 의존성 원칙

_안정성의 방향으로(더 안정된 쪽에) 의존하라._

설계는 변경이 불가피하며 정적이지 않다. 컴포넌트 중 일부는 변동성을 지니도록 설계되며, 우리는 이러한 컴포넌트를 보고 언젠간 변경되리라고 예상한다.

**변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존해선 안된다.** 만약 내가 변경하기 쉬운 모듈을 만들었다 하더라도, 누군가가 이 모듈에 의존성을 달아버리면 변경하기 어려워진다.

안정된 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진(변동성 있는) 모듈에 의존하지 않도록 만들 수 있다.

### 안정성

**'안정성'** 은 무엇인가? 안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없다. 소프트웨어에서 **안정적인 컴포넌트란 들어오는 의존성이 많아지는 것을 의미한다.** 예를 들면 다음 그림 14.5 의 X 컴포넌트는 안정적이다.

![alt text](/img/chapter14/stable-component.png)
_그림 14.5 X는 안정된 컴포넌트다._

세 컴포넌트가 X 에 의존하기에, X 를 변경하지 말아야 할 이유는 세가지가 된다. 이 경우 **X는 다른 세 컴포넌트를 '책임진다'** 라고 말한다. 반대로 **X는 어디에도 의존하지 않아 '독립적이다'** 라고 말한다.

반면, 그림 14.6의 Y는 불안정한 컴포넌트다. 어떤 컴포넌트도 Y에 의존하지 않아 책임성이 없고 변경하지 말아야할 이유는 없다. 반대로 변경이 발생할 수 있는 외부 요인이 세가지가 된다.

![alt text](/img/chapter14/unstable-component.png)
_그림 14.6 Y는 상당히 불안정한 컴포넌트다._

### 안정성 지표

컴포넌트의 안정성을 측정하는 방법은 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보는 방법이 있을 수 있다. 이 숫자를 통해 컴포넌트가 위치상 어느 정도의 안정성을 가지는지 계산할 수 있다.

- _Fan-in_: **안으로 들어오는 의존성**. 이 지표는 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타낸다.
- _Fan-out_: **바깥으로 나가는 의존성**. 이 지표는 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타낸다,
- _I(불안정성)_: `I = Fan-out / (Fan-in + Fan-out)`. 이 지표는 [0,1] 범위의 값을 갖는다. **I=0이면 최고로 안정된 컴포넌트**라는 뜻. **I=1이면 최고로 불안정한 컴포넌트**라는 뜻.

Fan-in과 Fan-out 지표는 특정 컴포넌트의 내부 클래스에 의존하는, 컴포넌트 외부에 위치한 클래스의 개수를 세어서 계산한다. 다음 예제를 살펴보자.

![alt text](/img/chapter14/fan-example.png)
_그림 14.7 예제_

Cc 컴포넌트의 안정성을 계산해 보자. Cc 내부의 클래스에 의존하는 외부의 클래스는 세 개다. 따라서 **Fan-in=3**이다. 또한 Cc 내부의 클래스가 의존하는 Cc 외부 클래스는 한개이다. 따라서 **Fan-out=1**이다. 결과적으로 **I=1/4** 이다.

C++ 에서 이러한 의존성은 대체로 #include문으로 표현되며, 실제로 소스 파일이 클래스당 하나가 되도록 구조화 하면 I 지표를 쉽게 구할 수 있다. 자바의 경우 I 지표는 import 구문과 완전한 클래스 일므의 개수를 세어 계산가능하다.

- I 가 1이면, 이 컴포넌트는 책임성이 없으며 의존적이다. 자신에게 의존하는 컴포넌트는 없으며, 자신이 의존하는 컴포넌트는 많다. 따라서 이 컴포넌트를 변경하지 말아야할 이유가 없다.

- 반대로 I 가 0이면, 이 컴포넌트는 다른 컴포넌트를 책임지며 독립적이다. 자신에게 의존하는 컴포넌트가 많으며, 자신이 의존하는 컴포넌트는 없다. 따라서 이 컴포넌트를 변경하기는 어렵지만, 이 컴포넌트에 의존하는 컴포넌트를 변경하는데 제약은 없다.

SDP에서 컴포넌트의 I 지표는 그 컴포넌트가 의존하는 다름 컴포넌트들의 I보다 커야한다고 말한다. 즉, 의존성 방향으로 갈수록 I 지표 값이 감소해야한다.

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다. 우리가 실제로 기대하는 컴포넌트 구조는 불안정한 컴포넌트도, 안정한 컴포넌트 둘다 공존하는 상태다. 그림 14.8의 다이어그램은 세 컴포넌트로 구성된 시스템이 가질 수 있는 이상적인 구조다.

![alt text](/img/chapter14/ideal-components.png)
_그림 14.8 세 컴포넌트로 구성된 시스템의 이상적인 구성_

위쪽에는 변경 가능한 컴포넌트가 보이고, 아래의 안정된 컴포넌트에 의존한다. 

그림 14.9는 SDP가 어떻게 위배될 수 있는지를 보여준다.
![alt text](/img/chapter14/sdp-violation.png)

`Flexible`은 변경하기 쉽도록(I -> 1, 불안정한) 설계한 컴포넌트다. 따라서 우리는 `Flexible`이 불안정한 상태이기를 바라는데, `Stable`에서 `Flexible`로 의존성이 생겨버렸다. 

이로 인해 SDP가 위배되는데, `Stable`의 I지표가 `Flexible`의 I지표보다 더 작기 때문이다. 결국 `Flexible`은 변경하기 어렵게 되었다.

이 문제를 해결하려면 둘 사이의 의존성을 끊어야 한다. 이 의존성이 다음과 같은 이유로 존재한다고 가정해보자. `Stable` 내부의 클래스 `U`는 `Flexible` 내부의 클래스 `C`를 사용한다.

![alt text](/img/chapter14/stable-uses.png)
_그림 14.10 Stable 내부의 클래스 U가 Flexible 내부의 클래스 C를 사용한다._

DIP를 도입하면 이 문제를 해결할 수 있다. 먼저 `US`라는 인터페이스를 생성한다. 이 인터페이스에는 `U`가 사용하는 모든 메서드가 선언되어 있어야 한다. 그러고 나서 그림 14.11 처럼 `C`가 해당 인터페이스를 구현하도록 만든다. 이를 통해 둘 사이의 의존성을 끊고 대신, 두 컴포넌트 모두 `US`인터페이스를 가진 `UServer` 컴포넌트를 의존하도록 강제한다.

![alt text](/img/chapter14/us.png)
_그림 14.11 C는 US 인터페이스를 구현한다._

이렇게 하면, `Flexible` 은 원래 의도한 I=1을 그대로 유지할수 있으며, 모든 의존성은 I가 감소하는 방향으로 향한다.

### 추상 컴포넌트

오로지 인터페이스만을 포함하는 컴포넌트(위의 경우 UServer)를 생성하는 방식이 이상해보일 수 있다. 하지만 이러한 추상 컴포넌트는 정적 타입 언어를 사용할 때 흔하고 꼭 필요한 전략으로 알려져 있다. **추상 컴포넌트는 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.**

동적 타입 언어에서는 추상 컴포넌트가 존재하지 않을 뿐아니라, 필요가 없다. 이들 언어에서의 의존성 구조는 훨씬 단순하며, 의존성을 역전 시킬 때 인터페이스를 선언하거나 상속받는 일이 필요하지 않기 때문이다.

## SAP: 안정된 추상화 원칙

_컴포넌트는 안정된 정도만큼만 추상화되어야 한다._

### 고수준 정책을 어디에 위치시켜야 하는가?

시스템에는 자주 변경해선 안되는 소프트웨어도 있다. 고수준 아키텍처나 정책 결정과 관련된 소프트웨어가 그 예다. 따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(I=0)에 위치시켜야 한다.

하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기 어려워진다. (안정적인 컴포넌트는 변경하면 안되는 이유들이 많기 때문에) 

그렇다면 컴포넌트가 최고로 안정된 상태이면서 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을
까? 그 해답은 OCP(개방 폐쇄 원칙)에서 찾을 수 있다. 

OCP는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있을 뿐만 아니라 바람직한 방식이라 말한다. **추상 클래스**가 이 원칙을 준수한다.

### 안정된 추상화 원칙

안정된 추상화 원칙은 안정성과 추상화 정도사이의 관계를 정의한다.

한편으로 이 원칙은 안정된 컴포넌트는 추상 컴포넌트여야 하며, 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말한다. 안정성이 컴포넌트를 확장하는 일을 방해해서는 안되고, 불안정한 컴포넌트는 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.

따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다. 안정되 컴포넌트는 확장이 가능해지고 유연해져, 아키텍처를 과도하게 제약하지 않게 된다.

### 추상화 정도 측정하기 

A 지표는 컴포넌트의 추상화 정도를 측정한 값이다. 이 값은 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산한 값이다.

- _Nc_: **컴포넌트의 클래스 개수**
- _Na_: **컴포넌트의 추상 클래스와 인터페이스의 개수**
- _A_: **추상화 정도**. `A = Na / Nc`

A 지표는 [0,1] 사이의 값을 갖는다.

- **A가 0**이면, 컴포넌트에는 **추상 클래스가 하나도 없다**는 뜻이다.
- **A가 1**이면, 컴포넌트는 **오로지 추상 클래스만 포함**한다는 뜻이다.

### 주계열

이제 안정성(I)과 추상화 정도(A) 사이의 관계를 정의해야 한다. 이를 위해 수직축에 A를, 수평축에 I를 나타내는 그래프를 그린다. 최고로 안정적이고 추상화된 컴포넌트는 좌측 상단인 (0,1)에, 최고로 불안정하고 구체화된 컴포넌트는 우측 하단인 (1,0)에 위치한다.

![alt text](/img/chapter14/graph.png)
_그림 14.12 A/I 그래프_

모든 컴포넌트가 이 두 지점에 위치하는 것은 아닌데, 대체로 컴포넌트는 추상화와 안정화의 정도가 다양하기 때문이다. A/I 그래프 상에서 컴포넌트가 위치할 수 있는 합리적인 지점을 정의 하는 점의 궤적이 있으리라 가정할 수 있다. 이 궤적은 컴포넌트가 절대 위치해선 안 되는 영역, 다시 말해 배제할 구역을 찾는 방식으로 추론할 수 있다.

![alt text](/img/chapter14/zone-of-exclusion.png)
_그림 14.13 배제 구역(Zone of Exclusion)_

### 고통의 구역

(0,0) 주변 구역에 위치한 컴포넌트를 살펴보자. 이 컴포넌트는 매우 안정적이며 구체적이다.

이 컴포넌트는 바람직하지 못하다. 추상적이지 않아 확장할 수 없고, 안정적이므로 변경하기도 상당히 어렵기 때문이다. 따라서 제대로 설계된 컴포넌트라면 해당 위치에 자리할 수 없다. 이러한 구역을 배제할 구역, 고통의 구역이라고 부른다.

사실 일부 소프트웨어 엔티티는 고통의 구역에 위치하곤 한다. 

- 데이터베이스 스키마가 한 예다. 데이터베이스 스키마는 변동성이 높지만, 극단적으로 구체적이다.
- 구체적인 유틸리티 라이브러리도  예로 들 수 있다. 하지만 비록 이러한 라이브러리는 안정적이더라도 실제로는 변동성이 없다.

위의 유틸리티 라이브러리와 같이 변동성이 없는 컴포넌트는 고통의 구역에 위치해도 해롭지 않다. 이러한 이유로 소통의 구역에 위치한 컴포넌트가 변동이 크면 클수록 더욱 '고통스럽다'.

### 쓸모없는 구역

(1,1) 주변의 컴포넌트를 생각해보자. 여기도 바람직하지 않은데, 최고로 추상적인데, 누구도 이 컴포넌트에 의존하지 않는다. 따라서 쓸모가 없다. 이 영역은 쓸모없는 구역이라고 부른다.

이 영역에 존재하는 소프트웨어 엔티티는 폐기물과도 같다. 누구도 구현하지 않은채 남겨진 추상 클래스인 경우가 많다.

### 배제 구역 벗어나기

따라서 변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 멀리 떨어 뜨러야 한다. 각 배제 구역으로부터 가장 멀리 떨어진 점의 궤적은 (1,0)과 (0,1)을 잇는 선분이다. 저자는 이 선분을 주계열(Main Sequence)라고 부른다.

**주계열에 위치한 컴포넌트는 자신의 안정성에 비해 너무 추상적이지도 않고, 추상화 정도에 비해 너무 불안정하지도 않다.** 이 컴포넌트는 쓸모없지 않으면서, 너무 심각한 고통을 안겨 주지 않는다. 추상화된 수준에 어울릴 정도로만 다른 컴포넌트가 의존하며, 구체화된 수준에 어울릴정도로만 다른 컴포넌트에 의존한다.

컴포넌트가 위치할 수 있는 가장 바람직한 지점은 주계열의 두 종점이다.

### 주계열과의 거리

여기에서 세 번째 지표가 도출된다. 컴포넌트가 주계열과 가까이 있는게 바람직하다면, 컴포넌트가 주계열로 부터 얼마나 멀리 떨어져 있는지 측정하는 지표를 만들어 볼 수있다.

- _D4_: 거리. `D = |A + I - 1|`. 유효범위는 [0,1]. 
    - D가 0이면 컴포넌트가 주계열 바로 위에 위치한다는 뜻
    - D가 1이면 주계열로부터 가장 멀리위치한다는 뜻이다.

따라서 컴포넌트들의 D 지표를 계산하여, 0에 가깝지 않은 컴포넌트가 있다면 재검토한 후 재구성할 수 있다.

통꼐적으로 분석또한 가능해진다. 모든 컴포넌트에 대해 D 지표의 평균과 분산을 구한다. 분산을 통해 다른 컴포넌트에 비해 '극히 예외적인' 컴포넌트 또한 식별할 수 있다.

그림 14.14 를 살펴보자. 대부분의 컴포넌트는 주계열에 위치하지만, 일부 컴포넌트는 표준편차가 1 (Z=1)인 영역을 벗어나 있다. 이러한 이상한 컴포넌트는 면밀히 검토해 볼 가치가 있는 것이다.

![alt text](/img/chapter14/scatterplot.png)
_그림 14.14 컴포넌트 산점도_

D 지표를 활용하는 또 다른 방법으로, 각 컴포넌트의 D 값을 시간에 따라 그려볼 수 있다. 그림 14.15가 그 예시이다. 보다시피 마지막 몇 개의 릴리스에서 `Payroll` 컴포넌트에 이상한 의존성이 스며들어온 사실을 알 수 있다.

![alt text](/img/chapter14/plot-of-d.png)
_그림 14.15 단일 컴포넌트에 대해 시간에 따른 D 값을 표시한 도표_

## 결론

이 장에서 설명한 의존성 관리 지표들은 설계의 의존성과 추상화 정도가 내가 '훌륭한' 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.
