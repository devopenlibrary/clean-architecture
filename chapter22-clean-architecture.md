# 22장 클린 아키텍처

지난 수십 년간 시스템 아키텍처와 관련된 여러 가지 아이디어를 봐왔다. 다음의 내용도 여기에 포함된다.

- 육각형 아키텍처(Hexagonal Architecture): 포트와 어댑터라고도 알려졌으며, 앨리스터 코오번이 개발했다.
- DCI(Data, Context and Interaction): 제임스 코플리언과 트리그베 린스쿠그가 만들었다.
- BCE(Boundary-Control-Entity): 이바 야콥슨이 자신의 저서인 Object Oriented Software Engineering에서 소개했다.

이들 아키텍처의 목표는 모두 같은데, 바로 **관심사의 분리**다. 이들은 모두 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다. 각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.

이들 아키텍처는 모두 시스템이 다음과 같은 특징을 지니도록 만든다.

- **프레임워크 독립성**. 아키텍처는 다양한 기능의 라이브러리를 제공하는 소프트웨어, 즉 프레임워크의 존재 여부에 의존하지 않는다. 이를 통해 이러한 프레임워크를 도구로 사용할 수 있으며, 프레임워크가 지닌 제약사항 안으로 시스템을 욱여넣도록 강제하지 않는다.
- **테스트 용이성**. 업무 규칙은 UI, 데이터베이스, 웹 서버, 또는 여타 외부 요소가 없이도 테스트할 수 있다.
- **UI 독립성**. 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다. 예를 들어 업무 규칙을 변경하지 않은 채 웹 UI를 콘솔 UI로 대체할 수 있다.
- **데이터베이스 독립성**. 오라클이나 MS SOL 서버를 몽고DB, 빅테이블, 카우치DB 등으로 교체할 수 있다. 업무 규칙은 데이터베 이스에 결합되지 않는다.
- **모든 외부 에이전시에 대한 독립성**. 실제로 업무 규칙은 외부 세계와의 인 터페이스에 대해 전혀 알지 못한다.

그림 22. 1의 다이어그램은 이들 아키텍처 전부를 실행 가능한 하나의 아이디 어로 통합하려는 시도다.

![alt text](/img/chapter22/the-clean-architecture.png)
_그림 22.1 클린 아키텍처_

## 의존성 규칙

그림 22.1에서 각각의 동심원은 소프트웨어에서 서로 다른 영역을 표현한다. **보통 안으로 들어갈수록 고수준이 된다**. 바깥쪽은 메커니즘, 안쪽은 정책이다. 이러한 아키텍처가 동작하도록 하는 가장 주요한 규칙은 의존성 규칙이다.

_소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다._

**내부 원의 요소는 바깥 원의 요소에 대해 알지 못해야한다**. 혹은 바깥쪽의 함수, 클래스, 변수 등을 언급해서는 안된다.

같은 이유로 **외부의 원의 요소도 내부의 원에서 절대로 사용해서는 안된다**.

### 엔티티

**엔티티는 전사적인 핵심 업무 규칙을 캡슐화 한다**. 전사적이지 않은 단일 애플리케이션을 작성하고 있다면 그 엔티티는 해당 애플리케이션의 업무 객체가 된다. 이 경우 엔티티는 가장 일반적이며 고수준인 규칙을 캡술화 한다. **외부의 무언가가 변경되도 엔티티가 변경될 가능성은 지극히 낮다**.

### 유스케이스

유스케이스 계층의 소프트웨어는 **애플리케이션에 특화된 업무 규칙을 포함**한다. 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해 유스케이스의 목적을 달성하도록 이끈다.

**유스케이스 계층에서 발생한 변경이 엔티티에 영향을 미쳐서는 안된다**. 또한, DB, UI, 프레임워크와 같은 외부 요소에서 발생한 변경이 유스케이스 계층에 영향을 줘서도 안된다. 유스케이스 계층은 이러한 관심사로부터 격리되어있다.

### 인터페이스 어댑터

인터페이스 어댑터 계층은 일련의 어댑터들로 구성된다. 어댑터는 **데이터를 유스케이스와 엔티티에게 가장 편리한 형식**에서 **데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식**으로 **변**환한다. 마찬가지로 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 프레임워크가 이용하기에 가장 편리한 형식으로 변환한다.

이 계층은. 예를 들어 GUI의 MVC 아키텍처를 모두 포괄한다. 프레젠터, 뷰, 컨트롤러는 모두 인터페이스 어댑터 계층에 속한다.

또한 이 계층에는 데이터를 외부 서비스와 같은 **외부적인 형식**에서 유스케이스나 엔티티에서 사용되는 **내부적인 형식으로 변환**하는 또 다른 어댑터가 필요하다.

### 프레임워크와 드라이버

가장 바깥쪽 계층은 일반적으로 DB나 웹 프레임워크 같은 프레임워크나 도구들로 구성된다. 이 계층은 일반적으로 안쪽 원과 통신하기 위한 접합 코드 외에는 특별히 더 작성할 코드가 많지 않다.

**프레임워크와 드라이버 계층은 모든 세부사항이 위치하는 곳이다. 웹, DB는 세부사항이다. 이는 외부에 시켜 피해를 최소화한다.**

### 원은 네 개여야만 하나?

그림 22.1에서 사용된 원들은 그저 개념을 설명하기 위한 하나의 예시이다. 네 개만 사용되었지만, 더 많은 원들이 필요할 수 있다.

하지만 중요한 것은 **어떤 경우에도 의존성 규칙은 적용**된다. 소스 코드 의존성은 항상 안쪽을 향한다. 항상 저수준에서 고수준을 향한다. **안쪽으로 이동할수록 소프트웨어는 점점 추상화되며, 범용적이게 된다.**

### 경계 횡단하기

우측 하단 다이어그램에 원의 경계를 횡단하는 방법을 보여주는 예시가 있다. 이 예시에서 컨트럴로와 프레젠터가 다음 계층에 속한 유스케이스와 통신하는 모습을 확인할 수 있다. 

우선 제어흐름에 주목해보자. 제어흐름은 컨트롤러에서 시작해, 유스케이스를 지난 후, 프레젠터에서 실행되면서 마무리된다. 소스 코드 의존성은 유스케이스를 향해 안쪽을 가리킨다.

**이처럼 제어흐름과 의존성이 반대여야하는 경우, 대체로 DIP를 통해 해결한다**. 예를 들어 자바에서는 인터페이스와 상속 관계를 적절하게 배치함으로써, 제어흐름이 경계를 가로지르는 바로 그 지점에서 소스 코드 의존성을 제어흐름과는 반대가 되게 만들 수 있다.

예를 들어 유스케이스에서 프레젠터를 호출해야 한다고 가정해보자. 이때 직접 호출하면 내부 원이 외부원을 언급하는 의존성 규칙을 위배하게 된다. 따라서 **유스케이스가 내부 원의 인터페이스(출력 포트)를 호출하도록 하고, 외부 원의 프레젠터가 그 인터페이스를 구현하도록 만든다.**

아키텍처 경계를 횡단할 때 이러한 기법을 사용할 수 있다. 동적 다형성을 이용해 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다.

### 경계를 횡단하는 데이터는 어떤 모습인가

경계를 가로지르는 데이터는 흔히 간단한 데이터 구조로 이루어져 있다. 중요한 점은 **격리되어 있는** 간단한 데이터 구조가 경걔계를 가로질러 전달된다는 사실이다. 꾀를 부려 엔티티 객체나 데이터베이스의 행을 전달하는 일은 원치 않는다.

**따라서 경계를 가로지르는 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야만 한다.**

## 전형적인 시나리오

그림 22.2는 데이터베이스를 사용하는 웹 기반 자바 시스템의 전형적인 시나리오를 보여준다. 

![alt text](/img/chapter22/typical-scenario.png)

1. 웹 서버는 사용자로부터 입력 데이터를 모아서 좌측 상단의 `Controller` 로 전달한다. 
2. `Controller`는 데이터를 평범한 자바 객체(POJO)로 묶은 후, `InputBoundary` 인터페이스를 통해 `UseCaseInteractor`로 전달한다.
3. `UseCaseInteractor`는 이 데이터를 해석해 `Entities`가 어떻게 사용하는지를 제어하는 데 사용한다. 
4. `Entities`가 완성 되면, `UseCaseInteractor`는 `Entities`로 부터 데이터를 모아 또다른 POJO인 `OutputData`를 구성한다.
5. `OutputData`는 `OutputBoundary`를 통해 `Presenter`로 전달된다.
6. `Presenter`는 `OutputData`를 `ViewModel`과 같이 화면에 출력할 수 있는 형식으로 재구성한다.
7. `ViewModel`또한 POJO로, 주로 문자열과 플래그로 구성된다.
8. `View`에서는 `ViewModel`의 데이터를 화면에 출력한다.

의존성의 방향에 주목하자. 모든 의존성은 의존성 규칙을 준수해 경계선을 안쪽으로 가로지른다.

## 결론

소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될것이다. 데이터베이스나 프레임워크와 같은 시스템의 외부 요소가 구식이 되더라도, 이들 요소를 야단스럽지 않게 교체할 수 있다.