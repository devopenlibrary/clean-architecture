# 1장 설계와 아키텍처란?

시스템을 동작하게 만드는 것은 쉽지만 제대로 만드는 일은 어렵다

제대로 만들려면 **적정 수준의 지식과 기술**, 그리고 **사고력과 통찰력**이 필요하다.

잘 만들어진 시스템은 **소수의 개발자**만으로도 오랫동안 **안정적으로 동작**할 수 있다.

- 새로운 기능 추가와 유지보수가 쉽다
- 변경이 단순하고 반영이 빠르다
- 결함이 적고, 품질이 높다
- **기능과 유연성을 최소한의 노력으로 극대화**할 수 있다

**설계 (Design)**

- 저수준의 구조 또는 결정사항을 의미
    
    (예: 메서드 분리, 모듈 구성, 클래스 관계 등)
    

**아키텍처 (Architecture)**

- 고수준의 개념이나 구조
    
    (예: 계층 구조, 도메인 분리, 통합 방식 등)
    

하지만 실제로는 이 둘을 명확히 구분하기 어렵다.

**설계와 아키텍처는 단절 없는 하나의 연속성** 위에 있고,

고수준에서 저수준으로 이어지는 일련의 의사결정일 뿐이다.

## 목표는?

> 최소 인력으로 시스템을 만들고, 유지보수할 수 있게 하는 것
> 

좋은 설계의 척도는 곧 **요구사항을 만족시키는 데 들어가는 비용**이다.

- 시스템의 수명 내내 **이 비용을 낮게 유지**할 수 있다면 좋은 설계다.
- 반대로, 새로운 기능을 출시할 때마다 비용이 증가한다면 **나쁜 설계다.**



## 사례 연구

- 기능 출시마다 **개발자 수가 늘어남**
- 그럼에도 불구하고 생산성은 일정 수준에서 정체
- 라인당 비용은 **계속 증가**

👉 이런 시스템은?

- 비용 곡선이 수익을 갉아먹고
- 회사 성장은 멈춘다

### 엉망진창이 되어가는 신호

- 시스템을 급하게 만들기 시작
- 구조보단 **기능 완성**만 고려
- 프로그래머 수로만 작업량을 나누려 함
- 코드와 설계를 깔끔하게 하려는 **의지 부족**

> 개발자는 대부분의 시간을
> 
> 
> **엉망진창이 된 코드에 대응하는 데 소비**하게된다.
> 

### 경영자의 시각

- 같은 개발 기간이지만
- **릴리즈가 반복될수록 인건비는 증가**
- 유지보수비, 대응비용, 실패비용도 덩달아 증가

### 무엇이 잘못되었나?

개발자는 좋은 설계의 중요성을 안다. 하지만…

> "정리는 나중에 하자" → 나중은 **오지 않는다**
> 
- 시장 압박 때문에 빠르게 기능만 추가
- 구조 개선은 점점 멀어지고, 기술 부채는 누적됨
- 결국, 생산성은 **0에 수렴**하고, 시스템은 붕괴

**엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다.** 

개발자가 자기 능력을 과신하면 안 된다. 엉창진창의 코드가 서서히 쌓이면 개발자 생산성은 낮아지고, 코드가 엉망이 되는 추세도 멈추지 않는다. 

재설계를 해도 실수를 반복할 가능성이 높다.

**제이슨 고먼의 6일 실험**

- 단순한 프로그램을 6일간 구현
- 전반 3일: **TDD 적용**
- 후반 3일: **TDD 미적용**

✅ **결과:** 날이 지날수록 점점 **더 빠르게 완성됨**

> **빨리 가는 유일한 방법은, 제대로 가는 것이다.**
> 



## 결론

> 좋은 소프트웨어 아키텍처란?
> 
> 
> **비용은 최소화하고, 생산성은 최대화**할 수 있는 구조
> 

좋은 소프트웨어 아키텍처를 위해서는:

- **조직 전반의 과신**을 인식하고 통제해야 한다.
- 좋은 아키텍처가 가진 **속성**을 이해하고
- 그것을 조직 문화와 개발 프로세스에 적용해야 한다.