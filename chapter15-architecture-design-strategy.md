# 15장 아키텍처란?

**소프트웨어 아키텍트**

- **최고의 프로그래머**이며, **프로그래밍을 계속 수행해야 함**
    - 문제를 직접 경험하지 않으면 다른 개발자를 실질적으로 지원할 수 없기 때문
- **팀의 기술적 리더**
    - 팀 전체가 **생산성을 극대화할 수 있는 방향**으로 설계를 이끌어야 함

**소프트웨어 아키텍처**

아키텍처는 시스템을 구축한 사람들이 만들어낸 시스템의 형태이다

아키텍처의 형태는 다음 세 가지 요소로 결정된다

- 컴포넌트 분할 방식
- 컴포넌트 배치 방식
- 컴포넌트 간 의사소통 방식

아키텍처는 시스템이 **쉽게 개발, 배포, 운영, 유지보수**되도록 만들어진다.

**설계 전략**

가능한 많은 선택지를, 가능한 한 오래 남겨두자

- **유연성을** 최대한 보존하는 것이 중요
- 빠른 결정은 미래를 막는 장애물이 될 수 있다.

**시스템 동작과의 관계**

❓ 좋은 아키텍처 = 시스템이 잘 동작함❓

- 하지만 실제로는
    - 형편없는 아키텍처를 가진 시스템도 동작은 잘 될 수 있다.
    - 이런 시스템은 운영보다 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪는다.
- 아키텍처가 시스템이 제대로 동작하도록 지원하는 데 아무런 역할을 하지 않는 것은 아니지만 이 역할이 능동적이거나 본질적인 것은 아니다.

**아키텍처의 목적은 시스템의 생명주기를 지원하는 것**

👉 **시스템을 오랫동안 잘 다룰 수 있게 만드는 것**

좋은 아키텍처의 특성

- 시스템을 쉽게 이해할 수 있게 하고
- 개발, 배포, 운영, 유지보수를 쉽게 하며
- 프로그래머의 생산성을 극대화하고
- 전체 생명주기 동안의 비용을 최소화함

## 개발

시스템이 **개발하기 어려운 구조**라면 유지보수도 어렵고, 결국 **수명도 짧아진다**.

그래서  시스템 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 뒷받침해줘야 한다. 

**팀 규모에 따른 아키텍처 전략**

**작은 팀 (예: 개발자 5명 이하)**

- 서로 바로 소통 가능 → 컴포넌트나 인터페이스 없이도 협업이 가능
- 그래서 자연스럽게 모노리식 시스템(기능이 하나로 엮여 있는 구조)으로 시작하는 경우가 많음.
- 아키텍처적 제약이 오히려 귀찮은 방해물로 느껴질 수 있음.
- 그래서 많은 프로젝트가 아키텍처 없이 시작되고, 결과적으로 초기에 설계가 결여된 채 출발하게 됨.

**큰 팀 (예: 7명짜리 팀이 5개 있는 구조)**

- 규모가 커지면 커질수록 팀 간 의사소통 비용이 증가함.
- 이때는 컴포넌트 분리와 안정된 인터페이스 정의가 필수
    - 각 팀이 독립적으로 일하려면 자신이 맡은 영역이 명확해야 하고,
    - 다른 팀과는 안정적인 인터페이스을 통해 연결되어야 함.
- 이런 상황에서 아키텍처 없이 개발을 진행하면 혼란이 증가.
- 결국 각 팀이 하나의 컴포넌트를 맡는 방식으로 `팀 단위 = 컴포넌트 단위` 구조로 수렴하게 된다.

❗️ 팀별 단일 컴포넌트 아키텍처가 시스템 배포, 운영, 유지보수하는 데 최적일 가능성은 거의 없다. 그럼에도 여러 팀이 일정에만 쫓겨서 일한다면, 이 아키텍처로 귀착될 것이다.

## 배포

소프트웨어 시스템이 사용될 수 있으려면 반드시 배포할 수 있어야 한다.

- 아무리 훌륭한 시스템이라도 배포할 수 없다면 사용할 수 없다.
- 배포 비용이 높을수록 시스템의 **유용성↓**
- 따라서 시스템을 쉽게, 반복 가능하게 배포할 수 있도록 설계되어야 한다.

초기 개발 단계에서는 배포 전략을 거의 고려하지 않아 배포하기 상당히 어려운 아키텍처가 만들어진다. 

**예시**: 

1. 초기에 배포를 고려하지 않고 마이크로서비스 선택
2. 각 컴포넌트의 **경계가 뚜렷**하고, **인터페이스도 안정적**이어서 쉽게 개발
3. 배포 시점에
    - 서비스 개수가 위협적임
    - 서비스 간 의존성도 복잡하게 얽혀 있음

**만약 초기 단계에서 배포 전략을 함께 고려했다면?**

- 서비스 수를 최소화
- 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드로 구성
- 통합된 배포 도구로 상호 연결을 관리

## 운영

운영은 아키텍처에 덜 극적인 영향을 받는다. 

시스템 운영에서 발생하는 대부분의 문제는 아키텍처를 고치지 않고도 해결 가능하다.

- 예: 성능 문제 → 서버 추가, 스토리지 확장, 캐시 도입 등으로 해결
- 하드웨어는 싸고 빠르지만, 사람(개발자)의 시간은 비싸다
    
    → 운영에서 오는 문제는 돈으로 해결할 수 있는 경우가 많다
    

**하지만 좋은 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려준다.**

- 운영자가 시스템을 어떻게 다루고, 무엇을 모니터링하고, 어떤 설정을 바꿔야 하는지가 자연스럽게 드러나야 함
- 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔터티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다.
    - 개발자와 운영자가 시스템을 이해하기 쉬워지며, 따라서 개발과 유지보수에 큰 도움이 된다.
    

## 유지보수

유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 비용이 가장 많이 든다. 

- 기능 추가는 끝이 없고
- 버그는 필연적으로 생기며
- 그 둘을 고치기 위해 엄청난 인적 자원이 소모된다

유지보수의 가장 큰 비용은 **탐사**와 이로 인한 위험부담에 있다.

- 탐사: 새로운 기능 추가 또는 수정 시:
    - 어디를, 어떻게, 왜 바꿔야 하는지 찾는 과정
- 위험부담
    - 수정 후, 예상치 못한 곳에서 문제가 터지는 것

주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.

1. 시스템을 컴포넌트로 분리
    1. 책임을 나누고, 결합도 최소화
2. 안정된 인터페이스를 두어 서로 격리
    1. 컴포넌트끼리는 명확하고 안정적인 인터페이스을 통해서만 소통
3. 미래 변경에 대비한 설계
    1. 변경 가능성이 높은 부분은 **유연하게 구성**하고
    

## 선택사항 열어 두기

소프트웨어는 두 종류의 가치

- 행위적 가치
- **구조적 가치**
    - 소프트웨어가 ‘부드럽다’는 건 바꿔 달라는 요구가 왔을 때 어려움 없이 변형‑확장된다는 뜻.
    - 이러한 유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 상당히 크게 의존한다.

> **소프트웨어를 부드럽게 유지하는 방법은 
선택사항을 가능한 한 많이, 그 리고 가능한 한 오랫동안 열어 두는 것**
> 

 열어 둬야 할 선택사항이란? 

👉 중요치 않은 세부사항

| 구분 | 특징 |  |
| --- | --- | --- |
| 정책(Policy) | 모든 업무 규칙과 업무 절차를 구체화 | 비즈니스 규칙·업무 절차·도메인 핵심 로직 |
| 세부사항(Details) | 정책과 대화하려고 끼워 넣은 도구들. 바꿔도 정책 행위엔 영향 없음. | 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로 토롤 등 |

**아키텍트의 목표**

시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축한다.

👉 정책을 드러내고, 세부사항을 ‘나중에 꽂을 모듈’로 격리한다.

**세부사항 예시**

1. **데이터베이스 종류**: RDB? NoSQL? 
    - 비즈니스 로직은 관심 없어야 함.
2. **웹 서버·웹 기술**: HTML, Ajax, JSF
    - 웹인지 파일 전송인지조차 정책은 몰라야 함.
3. **REST/SOA/마이크로서비스**
    - 외부 인터페이스는 교체 가능하게 둔다.
4. **의존성 주입 프레임워크**
    - 객체 생성/탐색 방식은 나중 문제.

**선택사항을 열어 두면?**

- **결정 연기**
    - 아직 정보가 부족할 때 섣불리 정하지 않는다.
    - 시간이 흐르면 요구/제약이 명확해져 더 나은 선택 가능.
- **실험 가능성 확보**
    - DB·웹 프레임워크·통신 방식 등을 실제로 바꿔보며 비교‑검증.
    - 최종 마지노선이 다가올 때까지 “열린 옵션” 상태 유지.

**다른 누군가가 이미 그러한 결정을 내렸다면?** 

**회사에서 특정 데이터베이스, 특정 웹 서버, 또는 특정 프레임워크에 기여해왔다면?** 

- 뛰어난 아키텍트는 **정해졌어도 안 정해진 것처럼** 구조를 짠다.
- 여전히 결정을 가능한 한 오랫동안 연기하거나 변경할 수 있는 형태로 시스템을 만든다.
- 결정되지 않은 사항의 수 최대화한다.

## 장치 독립성

**장치 독립성 (Device Independence)**

- **소프트웨어가 구체적인 입출력 장치에 종속되지 않도록 하는 원칙**
- 코드는 “어디서 읽고 쓰는지”를 몰라도 동작해야 함.

**1960년대**

- 하드웨어와 코드가 한 몸
- 당시 프로그래머는 장치를 사용하려면 직접 조작하는 명령어를 써야 했음.
- **문제: 장치 변경 = 코드 재작성**
    - 성능 좋은 장치로 교체하고 싶어도 기존 코드가 전부 이전 장비 전용으로 짜여져 있어 교체 불가
    

**해결**

- 운영체제가 등장하면서 **입출력 장치를 추상화**
    - 입출력 함수가 무엇이든 같은 인터페이스로 접근
- 장치 교체는 운영체제 설정만 바꾸면 됨.

## 광고 우편

장치 독립성 실용적 이점 예시

**사례 요약**

 광고 우편을 인쇄하는 회사는 의뢰인이 고객 정보가 담긴 자기 테이프를 보내주면 개인화된 광고를 인쇄하는 프로그램을 작성.

**문제**

- 이 정보를 조합해 개인 맞춤 편지를 수 천 장 출력해야 했음.
- 처음에는 **IBM 360 + 라인 프린터**로 인쇄.
    - 이 방식은 값비싼 기계를 너무 오랜 시간 점유한다.
    - IBM 360은 월 임대료 수만 달러

**해결:**  출력 장치 변경

- 코드는 운영체제의 입출력 추상화를 사용해 작성해서 가능 했음
    - 유지보수비 절감 + 유연성 확보
- 테스트할 땐 IBM 360에 연결된 라인 프린터 사용.
- 실 운영은 자기 테이프에 출력하고 오프라인에서 5대의 오프라인 프린터로 대량 인쇄.
    - 고성능 장비의 사용 시간 절약
    - 출력 장치 병렬 사용 → 생산량 극대화

## 물리적 주소 할당

물리적 주소 하드코딩의 위험성

**사례 요약**

회계 시스템 개발 중

- 디스크 드라이브 용량: 25MB
- Agent, Employer, Member 각각의 레코드 타입에 맞춰 디스크의 실린더·헤드·섹터를 물리적으로 포맷
    - 소프트웨어가 디스크의 상세 구조를 알고 있음
    - 소프트웨어는 어느 실린더가 어떤 Agent, EmpLoyer, Member를 포함하는지 알고 있고, 이러한 정보가 모두 하드코딩 되어 있음.
- 색인도 물리적 주소 기반 (실린더 번호, 헤드 번호, 섹터 번호를 포함)
- Member는 다음의 Member 레코드와 이전의 Member 레코드에 대한 실린더 번호, 헤더 번호, 섹터 번호도 포함

**문제:** 디스크 구조가 바뀜

- 새 디스크에선 실린더 수, 헤드 수, 섹터 수가 다름 → **주소 모두 무효화**
- 색인도, 연결 리스트도, 모든 로직도 깨짐
- 수많은 코드에 박혀 있는 하드코딩된 물리 주소를 다 뜯어내야 함
- 데이터를 옮기기 위해선 “주소 변환 프로그램”까지 만들어야 함

**해결:**  상대 주소 사용  + 추상화

- 디스크를 단순히 섹터들의 순차 배열로 간주
- 섹터에 번호 붙이기: `0, 1, 2, ..., N`
- 레코드 간의 링크는 “N번째 섹터”를 가리킴
- 변환 루틴: 상대 주소 ↔ 실린더/헤드/섹터 매핑

**효과**

- 고수준 로직이 물리 디스크 구조를 전혀 몰라도 됨
- **장치 교체 자유화** + 코드 수정 최소화

## 결론

> 좋은 아키텍트란 ‘정책’과 ‘세부사항’을 분리하고,
세부사항에 대한 결정을 가능한 한 오랫동안 미룬다.
>