# 28장 테스트 경계

_테스트는 시스템의 일부이며, 아키텍처에도 관여한다._

## 시스템 컴포넌트인 테스트

테스트와 관련한 상당한 혼동이 있다. 테스트는 시스템의 일부인가? 별개인가? 단위 테스트와 통합 테스트는 서로 다른가? 등등.

아키텍처 관점에서는 모든 테스트가 동일하다. TDD로 생성한 아주 작은 테스트이든, 아니면 대규모의 FitNesse, Cucumber, SpecFlow, JBehave 테스트이든, 이들 테스트는 아키텍처적으로 모두 동등하다.

**테스트는 태생적으로 의존성 규칙을 따른다**. 테스트는 세부적이며 **구체적**이다. 따라서, 의존성은 항상 테스트 대상이 되는 코드를 따른다. 실제로 **테스트는 아키텍처에서 가장 바깥쪽 원**으로 생각할 수 있다. 그렇기에 시스템 내부의 어떠한 컴포넌트도 테스트에는 의존하지 않으며, 테스트는 항상 원의 안쪽으로 향하게 된다.

**테스트는 독립적으로 배포 가능하다.** 대다수의 경우 테스트는 테스트 시스템에만 배포하며, 상용 시스템에는 배포하지 않는다. 

**테스트는 시스템 컴포넌트 중에서 가장 고립되어 있다.** 테스트는 시스템 운영에 꼭 필요치 않는다. 사용자는 테스트 중 그 어떠한 것에도 의존하지 않는다. 하지만 그렇다해서 테스트가 시스템 컴포넌트가 아니라는 뜻은 아니다. 사실 많은 면에서 **테스트는 다른 모든 시스템 컴포넌트가 반드시 지켜야 하는 모델을 표현**해준다.

## 테스트를 고려한 설계

테스트가 지닌 고립성과 대체로 테스트는 배포하지 않는다는 점 때문에 **테스트를 시스템 범위 밖에 있다고 생각하는 관점**이 있는 데, 이는 **치명적**이다. 테스트와 시스템이 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고 시스템은 변경하기 어려워진다.

물론 테스트와 시스템을 통합할 때 **고려해야할 문제는** **결합**이다. **시스템에 강결합된 테스트라면 시스템이 변경할 때마다 함께 변경**되어야 한다. 이는 시스템의 사소한 변경에도, 이와 결합된 수많은 테스트를 망가뜨릴 수 있다는 뜻이기도 하다. 이러한 문제는 깨지기 쉬운 테스트 문제(Fragile Tests Problem)으로 알려져 있다.

예를 통해 이 문제가 어떻게 발생하는지 살펴보자. 

```text
GUI를 사용해 업무 규칙을 검증하는 테스트 스위트(Test Suite)가 있다고 치자. 테스트들은 로그인 화면에서 시작해 페이지 구조를 탐색해 나가며 업무 규칙을 검사할 것이다. 
```

이 경우, 로그인 페이지 혹은 탐색 구조 어딘가 변경된다면 엄청난 수의 테스트들이 망가질 것이다. 

이 문제를 해결하려면, 소프트웨어 설계의 첫 번째 규칙을 생각해보아야 한다. _"변동성이 있는 것에 의존하지 말라"_ 하지만, GUI는 변동성이 크다. 변동성이 큰 GUI에 의존한 테스트 스위트들은 분명 깨지기 쉽다. 따라서 **시스템과 테스트를 설계할 때, GUI를 사용하지 않고도 업무 규칙을 테스트할 수 있게** 해야한다.

## 테스트 API

이 목표(GUI를 사용하지 않고도 업무 규칙을 테스트할 수 있는)를 달성하려면 테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있도록 **특화된 API**를 만들면 된다. 

이러한 API는

- 보안 제약사항을 무시할 수 있으며,
- 데이터베이스와 같은 값비싼 자원은 건너띌수 있으며,
- 시스템을 테스트 가능한 특정 상태로 강제하는 강력한 힘을 지녀야만 한다.

이 API는 사용자 인터페이스가 사용하는 인터랙터와 인터페이스 어댑터들의 상위 집합이 될 것이다.

테스트 API는 단순히 테스트를 UI에서 분리하는 것만이 아닌, **테스트 구조를 애플리케이션 구조로부터 결합을 분리하는게 목표**다.

### 구조적 결합

구조적 결합은 테스트 결합 중 가장 강하며, 가장 은밀하게 퍼져나가는 유형이다. 

모든 상용 클래스에 테스트 클래스가 각각 존재하고, 상용 메서드에는 테스트 메서드 집합이 각각 존재하는 테스트 스위트가 있다고 가정해 보자. 이러한 테스트 스위트는 애플리케이션 구조에 강하게 결합되어 있다.

**테스트가 애플리케이션 구조에 강하게 겷합**되면, 상용 클래스나 메서드 중 **하나의 변경이 발생해도 다수의 테스트가 변경**되어야 한다. 결과적으로 테스트는 깨지기 쉬워지고, 이로 인해 상용 코드를 뻣뻣하게 만든다.

테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는 데 있다. 그렇게 하면 상용 코드를 리팩터링하거나 진화시켜도 테스트에는 전혀 영향을 주지 않는다. 또한, 반대로 테스트 코드를 리팩터링하거나 진화시켜도 상용 코드에는 영향을 주지 않는다.

이처럼 따로따로 진화할 수 있다는 점은 필수적인데, 시간이 지날수록 테스트는 계속해서 더 구체적이고 더 특화된 형태로, 상용 코드는 더 추상적이고 더 범용적인 형태로 변할 것이기 때문이다.

### 보안

테스트 API가 지닌 강력한 힘을 운영 시스템에 배포하면 위험에 처할 수 있다. 위험을 피하고 싶다면, 테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포할 수 있는 컴포넌트로 분리해야한다.

## 결론

**테스트는 시스템 외부에 있지 않고 시스템의 일부이다.** 따라서 세트스에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 테스트는 잘 설계돼야만 한다.

테스트를 시스템의 일부로 설계하지 않으면 테스트는 깨지기 쉽고 유지보수가 어려워진다. 